一. 常用函数:
1.指数函数:y = a^x ,a的取值范围为: a>0&a!=1。程序中默认为e为底。因为a=1时y = x。没太大意义。 a > 1:单调递增，0>a>1:单调递减。值域:(0,+∞)
2.对数函数:y = logaX,a>0&a!=1 => X = a^y  所以a=1时y=X没意义。 定义域:(0,+∞). 值域:(-∞,+∞)
3.幂函数:y = x^a  ,毕经过(1,1)。 值域:(0,+∞)

二. 导数
为什么导数是🔺z = f(X0 + X) - f(X0)  X是变化量
因为导数表示的速度，有速度说明有差值，没速度导数就是0

1.意义:
它表示速度，数学上是切线。
举例:
(1) s = f(t)
t0-t 的平均速度: v=f(t) - f(t0)/(t - t0)
t0的瞬时速度:v = lim f(t)-f(t0)/(t-t0) => 导数
(2) 曲线 
某点的切线,
这里说下数学意义：
我们说切点时,是拿割线(也就是曲线的交叉线)。这样会成一个角度B。而,我们的切点角度是A.当割线与切线重合时，就是我们的导数。
我们的导数是tanA。它是从割线B逼近过来，公式来说是：tanA = f(x) - f(x0)/x-x0
x0就是切点的坐标，也就是割线。
limx->0 sinx/x=1
limx->∞(1+1/x)^x = e

2.凹凸性
(1)f(x1 + x2/2) < f(x1) + f(x2)/2 时是凹。反之凸，在凹凸的分解点叫拐点。
解析: f(x1) + f(x2)/2是平均值，假设是直线的话。如果低于这个平均值，那么就是直线下面，所以图像肯定是凹的。

(2)判别凹凸方法
f(x)在区间I有二阶导数。
f''(x) > 0,f(x)在I内图形是凹的。
f''(x) < 0,f(x)在I内图形是凸的。
解析:因为凹凸的本质是因为变化率发生了改变，也就是增速或者减速，导致了由下(慢)到上(快)即为凹。反之凸。所以用二阶导数来说明，
如果>0肯定是速率增加，也就是由慢到快，即凹。

3.部分定义

(1) 极值问题(局部最优解)
f(x)在极值点x0可导，则f'(X0) = 0，则成为驻点。对可导函数来讲,极值点必为驻点。
解析:所谓的导数为0，就是速度为0，也就是下面它的速率要发生变化，速率为二阶导数，如果下面速率(二阶导数上升),说明这个就是极小值。
反之为极大值，这也说明了我们上面阶段是速率下降/上升，所以我们要用导数为0作为驻点，也就是最大/最小点。
这个意义很大，我们可以通过可视化，和一些推导公式去判断数据的分布结果。
注意：上面说的是极值，也就是局部最大/最小。并非全局。损失函数求得是全局。

(2) 最值问题(全局最优解)
理论上是max/min{极值集合}。实际上有俩个理论
a. f(x) 在[a,b]上单调,则它的最值必在端点处取到。
b. f(x) 在[a,b]上连续,则在(a,b)内可导,且有唯一驻点,若为极小值必为最小值点，若为极大值点必为最大值点。
解析: 
a. 单纯的单调说明数据分布是直线增/减，所以此时没有局部最优，纯线性问题就是极=最。
b. 因为驻点就一个，说明他是俩个线性组成的非线性，这种数据分布类似relu函数,此时找驻点(一阶导数为0)即可。

(3) 多元函数的偏导数 
跟普通导数一样: ▲z = f(X0+x,Y0) - f(X0,Y0)。 这个函数是X导，Y不导。 再多元也是同理。
也可以化为极限分母除以X->0. 
解析：偏导的本质是求某变量维度的发生改变，其他变量不变，来观察数据的结果。

关于极值的定义：在各个变量有偏导数且有极值，则在各个地方为0.
求最值同理。



三.导数的应用
1. 求最大值和最小值,为损失函数优化做准备。并排除可能性。

2. 与非线性的结合。
比如f(x) = 2x^3-9x^2+12x-3的单调区间
=》<=1 时单调增加,1-2时单调减少,大于等于2时单调增加。

3. 泰勒应用
本质是无限逼近最优点。这里我只用自己话说下原理。
案例:
f(x) = a1x^3 + a2x^2 + a3x + b
多项式为非线性。
泰勒的公式各个项的导数集合+Rn(x) 这个Rn(x)你可以理解为偏执项,也可以理解为偏执项 + 正则项。
Rn(x)叫余项: 
(1) 佩亚诺余项:   Rn(x) = o[(x-x0)^n]
(2) 拉格朗日余项: Rn(x) = f(n+1)[X0 + θ(X-X0)].(X-X0)^n+1/(n+1)!
拉格朗日精度要更高。但时间复杂更高。

本质是不同导数,不同曲线点，不同逼近，但如果过于逼近，就是过拟合。我们做特征，让其非线性时增加2，3，4.。。。n次特征就是这个分本质，n越逼近准确值，
但越容易过拟合，其中,每次的前一个数比后面数之和都要大。


四. 拉格朗日乘法 

1.原理本质 
拉格朗日的本质是，将有约束的求极值问题转化为无约束的求极值问题。可以理解为它的本质是增加了惩罚因子。具体如下：
拉格朗日乘子法是用于变量无关的是常数lambda(j = 1,2,...), 分别乘各约束函数  并与目标函数相加得到如下的拉格朗日函数：
L(x,lambda,v) = f(x) + Σlambda[g(x) + v^2] (这里有i=1... 以后都省略这块)。
式中：x  为自变量; lambda 为拉格朗日乘子量; v 为松弛变量。
求解时需要将x,y,lambda的偏导数为0列出多个方程来求解。
也可以简写为：F(x,y:lambda) = f(x,y) + lambda.θ(x,y) 这是多元公式。
本质是有个惩罚因子，里面还有个v^2速率问题，它的应用本质如下：
假设目标函数代表一个工厂生产产品的数量，约束条件限制了生产中投入的原料和人力的总成本，我们求目标函数的极值，
就是要求在成本一定的条件下，如何分配利用人力和原料，从而使得生产量达到最大。此时λ便代表，当成本条件改变时，工厂可达到的生产量最大值的变化率。

2.机器学习的应用场景(特征工程:比如缺失值填充和部分算法的基础) 
参考： https://blog.csdn.net/z_x_1996/article/details/71705650
本质：最优化。
解决的问题: 求n元函数的损失问题时,通常时求极值转为最值的计算,在求解过程中分别求f(x)的各个变量的偏导数，转化为n个n元方程构成的方程组求解。
但是现实中这n个变量不是独立，需要满足一些约束,所以只是求导无法满足约束条件。

问题的本质: 自变量的相互独立性被约束条件破坏掉。

拉格朗日解决问题的本质: 引入拉格朗日乘子将含有n个变量和k个约束条件的约束优化问题转化含有(n+k)个变量的无约束优化问题。 
再本质的原因是: 将k个约束条件转化进偏导方程组中的k个等式从而使得原问题不再出现约束。
数学公式分解为：
minf(X)  s.t∴gi(X) = 0,i=1~k,X为n维向量。













