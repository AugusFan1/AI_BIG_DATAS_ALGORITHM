一.插入排序
1.算法讲解: 
  扑克牌打法就是类似插入排序。从第二个数开始，每次都跟前面比，比完交换位置。
  性能优化:虽然循环次数减少，但仍然是O(n^2),当然如果数学公式仔细推倒有个区间值会小于这个，先不说这个，由于每次循环俩俩交替次数太多，
  实际性能低于选择排序，所以这里有个性能优化点;将多余的交换次数变成赋值。也就是多做个备份。将后面内容与前面比较时同时前面数之间也比较，
  如果发现不是按照我们要的规律，则进行不停地赋值操作，这样以前的交换变成赋值，性能要快很多。
  这种特点是如果该数组是一个接近有序的数组，它的优势是特别大，因为少了很多次赋值操作，
  最后甚至接近 O(n)这种终极理想操作(对完全有序的排序他就是O(n)级别)，效率高于O(nlogn) 速度。

注意:程序语言中，判断部分是十分快速的，所以这里不记做操作时间里。所以插入排序中针对有序数组，虽然有n^2次判断，但赋值却一次没有，
     也就相当于O(n)级别,而赋值,创建对象/数组等数据结构,销毁对象/数组等数据结构会很慢,优化时以这个为出发点。

2.插入排序原始讲解
  原理就是从后往前找，每次都是调换，虽然这样循环次数减少，但swap操作却变得异常多，以前swap操作可能是n->n^2个，现在是接近n^2个。
  不过如果是正常排序，则不进行swap操作，会一直判断而已，注意:我们依次判断的是俩个相邻的数。但也可以这么想,如果第一个初始值最小，下面依次大.

3.插入排序优化讲解
  (1)我们如果将swap改成赋值，首先想到的是临时变量。最外层循环的第一个值是被我们所用的，所以初始化它。
  (2)其次我们想到我们赋值的条件，是这个初始值依次与它前面所有数比较，如果小，则依次对换。现在我们初始值是临时变量。
  (3)所以不用管它变换或者赋值，只需要管俩个相邻数之间赋值就行。一直到无法赋值也就是退出循环，这时候我们最后一次赋值的地方
  (4)因为我们的本质就是让初始值找到它应该放在的最小位置点上。
  (5)为了解决这个j位置，我们需要单独拿出j来。否则就无法跳出循环。

PS: swap转成赋值总结: 设定一个内存循环临时变量与arr[i]初始值临时变量来进行计算，最后依靠赋值改变j的位置让arr[i]这个临时变量最后赋值到它身上。


1.python版本:
# encoding: utf-8

# 普通方法
def insert_sort(list_temp):
    if len(list_temp) <= 1:
        return list_temp

    num = len(list_temp)
    for i in range(1, num):
        temp = list_temp[i]
        j = i - 1
        while j >= 0:
            if list_temp[j] > temp:
                list_temp[j + 1] = list_temp[j]
                list_temp[j] = temp
            j -= 1

    return list_temp


# 优化算法
def insert_sort2(list_temp):
    if len(list_temp) <= 1:
        return list_temp

    num = len(list_temp)
    for i in range(1, num):
        temp = list_temp[i]
        j = i
        while j > 0 and list_temp[j - 1] > temp:
            list_temp[j] = list_temp[j - 1]
            j -= 1

        list_temp[j] = temp

    return list_temp


if __name__ == "__main__":
    print('普通的插入排序结果: {0}'.format(insert_sort([5, 3, 2, 2, 1, 2, 3, 4, 5, 6])))
    print('优化后插入排序结果: {0}'.format(insert_sort2([5, 3, 2, 2, 1, 2, 3, 4, 5, 6])))







2.java版本:
(1) 普通版本

(2) 升级版本

3. c++版本:
(1) 普通版本
template <typename T>
void insertSort(T arr[], int n){
	assert(n >= 1);
	for (int i = 1; i < n; i++){
		for (int j = i; j > 0 && arr[j] < arr[j - 1]; j--)
			swap(arr[j], arr[j - 1]);
	}
}


(2) 升级版本
template <typename T>
void insertSortNew(T arr[], int n){
	assert(n >= 1);
	T min;
	int j;
	for (int i = 1; i < n; i++){
		min = arr[i];
//假设是完全有序,则j不会--,内存for循环会成O(1)操作，因为判断条件永远不成立,直接跳出循环。
		for (j = i; j>0 && min < arr[j - 1]; j--)
			arr[j] = arr[j - 1];
		arr[j] = min;
	}
｝

总结:接近有序和完全有序用没优化的选择排序，正常的小范围数组用选择排序。


2.希尔排序
(1) 希尔排序的宗旨:让有序数组变成基本有序，也就是小的在前面，大的在后面，中间的在中间。这样，让我们循环时候减少赋值或者swap操作。
(2) 方法:我们采用分割的方式，减少排序记录个数，变成基本有序。策略是跳跃性分割,将距离为某个增量的记录组成一个子序列。
保证子序列内进行插入排序得到的结果是基本有序而不是局部有序。这个数学方法证明很难，最终得到的结论是从n/2开始。是效率最高的。










