一.插入排序
python版本:
 普通版本:
 def insert_sort(list_temp):
    if len(list_temp) <= 1:
        return list_temp
    else:
        num = len(list_temp)
        for i in range(1, num):
            temp = list_temp[i]
            j = i - 1
            while j >= 0:
                if list_temp[j] > temp:
                    list_temp[j + 1] = list_temp[j]
                    list_temp[j] = temp
                j -= 1

        return list_temp

print(insert_sort([]))

升级版本:
def insert_sort_2(list_temp):
    if len(list_temp) == 1:
        return list_temp
    else:
        num = len(list_temp)
        # temp = 0
        # j = 0

        for i in range(1,num):
            temp = list_temp[i]
            j = i
            while j>0 and temp <list_temp[j-1]:
                list_temp[j] = list_temp[j-1]
                j -= 1
            list_temp[j] = temp
        return list_temp



java版本:

c++版本:
2.插入排序
扑克牌打法就是类似插入排序。从第二个数开始，每次都跟前面比，比完交换位置。
性能优化:虽然循环次数减少，但仍然是O(n^2),当然如果数学公式仔细推倒有个区间值会小于这个，先不说这个，由于每次循环俩俩交替次数太多，实际性能低于选择排序，所以这里有个性能优化点;

将多余的交换次数变成赋值。也就是多做个备份。将后面内容与前面比较时同时前面数之间也比较，如果发现不是按照我们要的规律，则进行不停地赋值操作，这样以前的交换变成赋值，性能要快很多。

这种特点是如果该数组是一个接近有序的数组，它的优势是特别大，因为少了很多次赋值操作，最后甚至接近 O(n)这种终极理想操作(对完全有序的排序他就是O(n)级别)，效率高于O(nlogn) 速度。
注意:程序语言中，判断部分是十分快速的，所以这里不记做操作时间里。所以插入排序中针对有序数组，虽然有n^2次判断，但赋值却一次没有，也就相当于O(n)级别。

//插入排序原始
//原理就是从后往前找，每次都是调换，虽然这样循环次数减少，但swap操作却变得异常多，以前swap操作可能是n->n^2个，现在是接近n^2个。
//不过如果是正常排序，则不进行swap操作，会一直判断而已，注意:我们依次判断的是俩个相邻的数。但也可以这么想,如果第一个初始值最小，下面依次大，

template <typename T>
void insertSort(T arr[], int n){
	assert(n >= 1);
	for (int i = 1; i < n; i++){
		for (int j = i; j > 0 && arr[j] < arr[j - 1]; j--)
			swap(arr[j], arr[j - 1]);
	}
}

//插入排序改进
//该算法的设计思路
//我们如果将swap改成赋值，首先想到的是临时变量。最外层循环的第一个值是被我们所用的，所以初始化它。
//其次我们想到我们赋值的条件，是这个初始值依次与它前面所有数比较，如果小，则依次对换。现在我们初始值是临时变量。
//所以不用管它变换或者赋值，只需要管俩个相邻数之间赋值就行。一直到无法赋值也就是退出循环，这时候我们最后一次赋值的地方
//就是j位置，我们将初始值赋值到这个位置就完事了(因为依次比较赋值后，最终一步会变成最后一个和倒数第二个都是一样的,所以需要将最后一个与初始值赋值
//因为我们的本质就是让初始值找到它应该放在的最小位置点上。
//为了解决这个j位置，我们需要单独拿出来。否则就无法跳出循环。
//优化点详解:我们将数组里的swap操作改成赋值操作，需要俩个临时变量，一个是我们最终要交换的内容，这个内容就是我们i要存放的最小值。当然我们可以换个角度考虑，找到一个索引值，这个索引值是i这个位置的值要放的位置，这样循环后也是有序的。所以我们创建另外一个int类型临时变量，当做这个索引值，当然它取代了内层循环的j,依靠内存循环j一直赋值(以前是交换)找到我们arr[i]要放的位置j,所以最终我们将arr[i]赋值给arr[j]即可。这里arr[i]放在了临时变量min中，因为min是临时变量就是j的初始化值，所以每次只需要跟min比较即可,因为比较条件成立,min这个位置上j会被前面所赋值，到时候所有条件成立的内容都会被前面值赋值，一直到最后一个也就是我们要找到的min.

//swap转成赋值总结: 设定一个内存循环临时变量与arr[i]初始值临时变量来进行计算，最后依靠赋值改变j的位置让arr[i]这个临时变量最后赋值到它身上。

template <typename T>
void insertSortNew(T arr[], int n){
	assert(n >= 1);
T min;
int j;
	for (int i = 1; i < n; i++){
		min = arr[i];
//假设是完全有序,则j不会--,内存for循环会成O(1)操作，因为判断条件永远不成立,直接跳出循环。
		for (j = i; j>0 && min < arr[j - 1]; j--)
			arr[j] = arr[j - 1];
		arr[j] = min;
	}
｝

总结:接近有序和完全有序用没优化的选择排序，正常的小范围数组用选择排序。
